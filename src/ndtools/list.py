"""
This module provides functionality to process duplicate media files.
"""

import json
import os
import sys

from dotenv import find_dotenv, load_dotenv

from model import MediaFile
from db import NavidromeDb
from utils import DotDict, PrintUtils as PU


class DuplicateProcessor:
    """
    This class processes duplicate media files.

    Attributes:
        db (NavidromeDb): The database connection to interact with the Navidrome database.
        dups_input (dict): A dictionary containing the raw duplicate media files references from Beets.
        media_files (dict): A dictionary containing the enhanced duplicate media files with data from Navidrome.
        stats (DotDict): A dictionary containing statistics about the processing of duplicate media files.
        output_folder (str): The path to the output folder where processed files will be saved.
    """

    db: NavidromeDb
    dups_input: dict
    media_files: dict
    stats: DotDict
    errors: list
    output_folder: str

    def __init__(self, input_file_path: str, output_folder: str, db: NavidromeDb):
        """
        Initialize the DuplicateProcessor with a database and an input file containing duplicate media files.

        The input JSON file with media references is generated by the Beets `duplicatez` plugin.

        Args:
            input_file_path (str): Path to JSON file generated by the Beets `duplicatez` plugin.
            output_folder (str): Path to the output folder where processed files will be saved.
            db (NavidromeDb): The Navidrome data access object.
        """
        self.output_folder = output_folder
        self.db = db

        # Read the input JSON file containing duplicate media files references from Beets.
        with open(input_file_path, "r", encoding="utf-8") as file:
            self.dups_input = json.load(file)

        if not self.dups_input:
            PU.red(f"No duplicates found in input file '{input_file_path}'")
            sys.exit(1)

        # Init media file list
        self.media_files = []

        # Init logging objects
        self.errors = []
        self.stats = DotDict({"duplicate_records": 0, "duplicate_files": 0, "media_files": 0, "file_annotations": 0})

    def replace_base_path(self, source_base: str, target_base: str):
        """
        Replace the music library base location with the actual location.

        This is required since the base paths of files may differ between the Beets and Navidrome library.

        Args:
            source_base (str): Paths in the JSON file are relative to this path.
            target_base (str): The actual location in the Navidrome music library.
        """
        if not source_base or not target_base:
            PU.orange("Skipping base path update")
            return
        if source_base == target_base:
            PU.orange("Skipping base path update as target equals source")
            return

        for paths in self.dups_input.values():
            for i, item in enumerate(paths):
                paths[i] = item.replace(source_base, target_base, 1)
        PU.green(f"Updated all base paths from '{source_base}' to '{target_base}'")

    def query_media_data(self):
        """
        Query the Navidrome database for each duplicate file and get all relevant data.
        """
        for key in self.dups_input.keys():
            print("")
            print(f"[*] Processing duplicate {key}")
            files = self.dups_input.get(key)
            self.stats.duplicate_records += 1

            for file in files:
                self.stats.duplicate_files += 1
                print(f"    Query {file}")
                media: MediaFile = db.get_media(file)
                self.media_files.append(media)
                self._log_info(file, media)
        self._print_stats()
        self._export_errors()

    def _log_info(self, file_path: str, media: MediaFile):
        """
        Log information about the media file.
        """
        if media:
            PU.green(f"     └─ {media}")
            self.stats.media_files += 1
            if media.annotation:
                PU.green("           └───── " + str(media.annotation))
                self.stats.file_annotations += 1
            if media.artist:
                PU.green("           └───── " + str(media.artist))
                if media.artist.annotation:
                    PU.green("                     └───── " + str(media.artist.annotation))
            else:
                self.errors.append({"error": "artist not found", "path": file_path, "media": media})
                PU.red("           └───── Artist not found in database!")
            if media.album:
                PU.green("           └───── " + str(media.album))
                if media.album.annotation:
                    PU.green("                     └───── " + str(media.album.annotation))
            else:
                # This is not seen as an error because not all media files have an album
                PU.orange("           └───── Album not found in database!")
        else:
            self.errors.append({"error": "media file not found", "path": file_path})
            PU.red("           └───── Media file not found in database!")

    def _print_stats(self):
        print("")
        print("-----------------------------------------------------")
        PU.green(" STATISTICS")
        print("-----------------------------------------------------")
        print("")
        PU.green(" Duplicates:")
        PU.green(f"     Records: {self.stats.duplicate_records}")
        PU.green(f"     Files: {self.stats.duplicate_files}")
        print("")
        PU.green(" Media files:")
        PU.green(f"     Found: {self.stats.media_files}")
        PU.green(f"     Annotations: {self.stats.file_annotations}")
        print("")
        PU.green(f" Artists: {len(self.db.artists)}")
        PU.green(f" Albums: {len(self.db.albums)}")
        print("")

    def _export_errors(self):
        print("-----------------------------------------------------")
        PU.green(" ERRORS")
        print("-----------------------------------------------------")
        if len(self.errors) > 0:
            error_file = self.output_folder + "/errors.json"
            PU.red(f"Exporting {len(self.errors)} errors to {error_file} ...")
            with open(error_file, "w") as f:
                json.dump(self.errors, f, indent=4)
            PU.red("Done!")
        else:
            PU.green(" No errors found.")
        print("-----------------------------------------------------")


if __name__ == "__main__":
    load_dotenv(find_dotenv())

    config_dir = None
    report_dir = None
    music_dir = None
    source_base = None
    target_base = None

    if os.getenv("DIR_CONFIG"):
        config_dir = os.getenv("DIR_CONFIG")
    if os.getenv("DIR_OUTPUT"):
        report_dir = os.getenv("DIR_OUTPUT")
    if os.getenv("DIR_MUSIC"):
        music_dir = os.getenv("DIR_MUSIC")
    if os.getenv("BEETS_BASE_PATH"):
        source_base = os.getenv("BEETS_BASE_PATH")
    if os.getenv("NAVIDROME_BASE_PATH"):
        target_base = os.getenv("NAVIDROME_BASE_PATH")

    db = NavidromeDb(f"{config_dir}/navidrome/navidrome.db")
    processor = DuplicateProcessor(f"{report_dir}/beets-duplicates.json", report_dir, db)
    processor.replace_base_path(source_base, target_base)
    processor.query_media_data()
